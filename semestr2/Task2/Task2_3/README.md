# Задача 2.3: Многопоточная работа с односвязным списком

###  Реализуйте односвязный список, хранящий строки длиной менее 100 символов, у которого с каждым элементом связан отдельный примитив синхронизации(за основу можно взять реализацию списка, на котором построен очередь queue_t). Такого списка может выглядеть, например, так:

        
        typedef struct _Node {
            char value[100];
            struct _Node* next;
            pthread_mutex_t sync;
        } Node;
        
        typedef struct _Storage {
            Node *first;
        } Storage;



### Задачи потоков
Первый поток: Пробегает по всему хранилищу и ищет количество пар строк, идущих по возрастанию длины. 
По достижении конца списка поток инкрементирует глобальную переменную, хранящую количество выполненных им итераций, и начинает новый поиск.

Второй поток: Пробегает по всему хранилищу и ищет количество пар строк, идущих по убыванию длины. 
По достижении конца списка поток инкрементирует глобальную переменную, хранящую количество выполненных им итераций, и начинает новый поиск.

Третий поток: Пробегает по всему хранилищу и ищет количество пар строк, имеющих одинаковую длину. 
По достижении конца списка поток инкрементирует глобальную переменную, хранящую количество выполненных им итераций, и начинает новый поиск.

Задачи трех дополнительных потоков
Запускаются три потока в непрерывном бесконечном цикле.
Каждый поток случайным образом проверяет, требуется ли переставлять соседние элементы списка (не значения),
и выполняет перестановку. Каждая успешная попытка перестановки 
фиксируется в соответствующей глобальной переменной-счетчике.

Синхронизация
Используются спинлоки, мутексы и блокировки чтения-записи для синхронизации доступа к элементам списка. 
Важно блокировать все записи с данными, над которыми производится работа, и блокировать три записи при перестановке элементов списка.

Тестирование
Проверяем решение для списков длиной 100, 1000, 10000, 100000, наблюдаем изменения (или отсутствие изменений) 
значений глобальных переменных-счетчиков и анализируем результаты.


Обратите внимание на следующие моменты при реализации:
- Продумайте решение, чтобы избежать ошибок соревнования.
- Блокируйте все записи с данными, которые обрабатываются.
- При перестановке записей списка блокируйте три записи.
- Чтобы избежать мертвых блокировок, захватывайте примитивы записей, более близкие к началу списка, всегда раньше.
